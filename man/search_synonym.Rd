% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/search.R
\name{search_synonym}
\alias{search_synonym}
\title{Search for Synonyms}
\usage{
search_synonym(
  conn,
  concept,
  schema = "mth",
  search_styles = c("exact", "string", "like"),
  split = " ",
  match_case = TRUE,
  cache_only = FALSE,
  skip_cache = FALSE,
  override_cache = FALSE
)
}
\arguments{
\item{conn}{Postgres connection}

\item{concept}{Concept to be searched}

\item{schema}{Metathesaurus schema}

\item{search_styles}{One or more of "exact", "string", and/or "like" search styles that correspond with the \code{\link{search_exact}}, \code{\link{search_string}}, and \code{\link{search_like}} functions respectively.}

\item{split}{Regular expression to split the concept on to generate words for this style of search. Defaults to a space.}

\item{match_case}{If TRUE, both the MRCONSO STR column and the `concept` argument are converted to lowercase.}

\item{cache_only}{If TRUE, only the cache is loaded and database querying is skipped. If a cache did not exist for the query, a NULL will be returned.}

\item{skip_cache}{If TRUE, the cache is skipped altogether. The database is directly queried and the resultset is not cached.}

\item{override_cache}{If TRUE, the cache is not loaded, the database is directly queried and the resultset is cached, overwriting any existing cache that may have been present.}
}
\value{
The results of the search will have all the fields from the MRCONSO Table with an additional Search Type column indicating what search type the CUI was the result of.
}
\description{
This function performs a combination of searches using the \code{\link{search_mrconso_functions}} on a `concept`. The resultsets are then rejoined back onto the MRCONSO to get all possible strings. The direction is therefore from the `concept` to the CUI it matches and then from the CUI back to all the STR values that belong to the CUI. The types of search to use depends on the `concept`. For example, a very long gene name may not have an exact match, but may have very high yield 'string' matches because of the number of unique words. A 'like' match may be the least ideal since it casts a wide net in the search and the return may be to wide in breadth to search the use case.
}
\seealso{
\code{\link[tibble]{tibble}}
 \code{\link[dplyr]{bind}},\code{\link[dplyr]{mutate}},\code{\link[dplyr]{select}},\code{\link[dplyr]{distinct}}
 \code{\link[SqlRender]{render}}
 \code{\link[pg13]{query}}
}
